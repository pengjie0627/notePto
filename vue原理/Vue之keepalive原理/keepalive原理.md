1、获取keep-alive包裹着的第一个子组件对象及其组件名（根据组件的name进行匹配）
2、根据include和exclude中设定的黑白名单（如果有）进行条件匹配，决定是否缓存。
不匹配，直接返回组件实例（VNode）。
如果匹配，根据组件ID和tag生成缓存Key， 并在缓存对象中查找是否已缓存过该组件实例。
如果之前缓存过，直接取出缓存值并更新该key在this.keys中的位置（放到尾部，更新key的位置是实现LRU置换策略的关键）
如果之前没缓存过，在this.cache对象中存储该组件实例并保存key值，
之后检查缓存的实例数量是否超过max的设置值，
超过则根据LRU算法删除最近最久未使用的实例（即是下标为0的那个key）
```
LRU算法指的是最近最少使用的算法。其实就是把缓存的组件中，每次使用到的组件对应的key值放在数组的最后面，
那么久而久之，最近最少使用的就会一直在数组的第0项，当缓存的组件超过设置的最大值时，就会把数组小标为0的
那一个删除
```
3、最后将该组件实例的keepAlive属性值设置为true
4、当再次加载已经缓存的组件时，就会把先前缓存的组件的vnode中的elm插入到父元素中