1、http的三次握手（建立连接）？
【1】第一次握手：客户端发送syn包（包含SYN=1，ACK=0，seq=x）到服务器，等待服务器确认
```
SYN=1：tcp协议中的一个标志位，表示要创建连接
ACK=0：tcp协议中的一个标志位，表示初始状态
seq=x：tcp协议中的一个标志位，值不一定是x，可以是一个随机数
```
【2】第二次握手：服务器收到syn包，必须确认客户端的syn包（表示同意连接），所以服务器会把syn包中的状态进行重置，
重置后syn包变为(SYN = 1, ACK = 1, seq = y)
```
SYN = 1：表示同意连接
ACK = 1：连接建立了，之后的ACK必须都置为1
seq = y：序列数随机，因为还没有数据，所以写什么都无所谓
```
然后，服务端会把刚才重置的syn包加上自己的ack包（sck = x + 1）
```
sck = x + 1：之前第一次握手的时候序列号说是发送的是seq=x第x位数据，所以我下次要的是x+1位的数据
```
发送给客户端，此时，服务端进行接收状态
【3】第三次握手：客户端接收到服务器的syn包和ack包后，向服务器发送ack确认包(ACK = 1, seq = x + 1, ack = y + 1)
```
ACK = 1：连接建立了
seq = x + 1：客户端告诉服务端我就发送的第一个字节就是你要的x+1
ack = y + 1：先前第二次握手，服务端告诉客户端说自己发的是第y位数据，所以我要y+1位的数据
```
此包发送完毕，客户端和服务器进入RSTABLISHEN状态，完成三次握手

2、http的四次挥手（关闭连接）？
前记：为什么要进行4次挥手？
```
由于TCP连接是全双工的，因此每个方向都必须单独进行关闭，这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接.
收到一个FIN只意味着这一方向没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
```
【1】第一次挥手：客户端发送一个FIN包(FIN = 1, seq = u)，用来关闭客户端A到服务器B的数据传送。
```
FIN = 1:tcp协议中的一个标志位,表示要释放连接了
seq = u:这个代表之前传递的数据的位置
```
【2】第二次挥手：服务器B收到这个FIN包(FIN = 1, seq = u)，它发回一个ACK(ACK = 1, seq = v, ack = u + 1)，
确认序号为收到的序号加1 ，一个FIN将占用一个序号。
```
ACK = 1：当前还是连接状态
ack = u + 1：客户端告诉服务端它发的是第u位数据，所以服务端告诉客户端服务端需要u+1位数据
seq = v：这里指的是之前已经发过的很多数据的序号
```
【3】第三次挥手：服务器B关闭与客户端A的连接，发送一个FIN包(FIN = 1, seq = w, ack = u + 1)给客户端A
```
FIN = 1:代表关闭连接
ack = u + 1：因为客户端直接不发数据了，所以第二段第三段的ack都是u+1
seq = w：代表之前发送的很多数据的序号
```
【4】第四次挥手：客户端收到服务端的FIN包后，客户端发回ACK(ACK = 1, seq = u + 1, ack = w + 1)报文确认，并将确认序号设置为收到序号加1
```
ACK = 1:当前还是连接状态
seq = u + 1:因为服务端已经不发消息了，所以序列号位置和之前服务端返回的相同
ack = w + 1:由于第三次握手服务端告诉我之前发送的序列号为w，所以我需要给它发的序号为w+1
```

注意：四次挥手中的第2次和第3次都是服务端发起的


2、为什么TCP连接需要三次握手而不是两次？
```
【1】确认双方的能力：两次握手只能保证一方（客户端）知道另一方（服务器）能够接收到它的消息并且回复，但是不能保证服务器也知道客户端能够接收到其回复。也就是说，仅通过两次握手，服务器无从得知客户端是否能成功接收到它发出的响应。这可能导致一种情况，即客户端认为连接已经建立，但服务器并不这么认为。
【2】同步初始序列号：TCP通信中使用序列号来保证数据包的顺序和可靠性。在三次握手中，客户端和服务器都有机会交换它们打算使用的起始序列号，并相互确认。这确保了双方都知道对方期望接收的数据流的开始位置，从而避免了由于序列号不匹配而导致的数据混乱。
【3】防止旧连接请求的干扰：三次握手有助于防止“已失效的连接请求报文段”突然又传送到服务器而产生错误。例如，一个延迟的连接请求可能在网络中滞留了一段时间后到达服务器，如果此时只需要两次握手就可以建立连接，那么这个过时的请求可能会被误认为是一个新的连接请求。通过三次握手，可以有效地避免这种情况的发生，因为第三次握手确保了双方都同意建立连接。
```

3、为什么TCP断开连接需要四次挥手？
```
【1】双方都需要单独确认关闭发送通道：在TCP连接中，任何一方都可以首先发起关闭请求（发送FIN），表示它已经完成了数据发送，并且不会再发送更多数据。但是，这并不意味着它不能再接收来自另一方的数据。因此，当一方发送FIN并收到另一方的ACK确认后，只表明这一方向上的数据发送可以停止了，但接收通道仍然可能处于活动状态。
【2】异步关闭过程：由于TCP连接是全双工的，所以每端必须单独关闭自己的发送通道。这意味着每一端都必须发送一个FIN来关闭自己的发送通道，并等待对方的ACK确认。如果两端几乎同时决定关闭它们的连接，则可能会看到两边都在发送FIN包，然后彼此发送ACK确认。这个过程自然需要至少四个步骤：两方各发送一次FIN，以及对这些FIN进行两次ACK确认。
【3】确保所有数据都被接收到：四次挥手确保了所有待发送的数据被成功传输到对方。例如，假设客户端认为它已经完成了所有的数据发送并发送了一个FIN给服务器。然而，服务器可能仍有未完成的数据要发送回客户端。通过四次挥手，服务器可以先确认客户端的FIN（此时服务器可能还在发送数据），并在之后准备好关闭时发送自己的FIN，最后由客户端给予确认。
【4】TIME_WAIT状态的重要性：在四次挥手中，主动关闭的一方在发送最后一个ACK之后会进入TIME_WAIT状态，这是为了确保被动关闭的一方能够收到最终的ACK确认。如果没有收到该ACK，被动关闭方将重发FIN。此外，TIME_WAIT状态还有助于处理网络中可能存在的延迟数据包，避免新建立的相同端口连接受到旧连接数据包的影响。
综上所述，四次挥手确保了TCP连接能够安全
```