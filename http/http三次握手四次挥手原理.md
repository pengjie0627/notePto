1、http的三次握手（建立连接）？
【1】第一次握手：客户端发送syn包（包含SYN=1，ACK=0，seq=x）到服务器，等待服务器确认
```
SYN=1：tcp协议中的一个标志位，表示要创建连接
ACK=0：tcp协议中的一个标志位，表示初始状态
seq=x：tcp协议中的一个标志位，值不一定是x，可以是一个随机数
```
【2】第二次握手：服务器收到syn包，必须确认客户端的syn包（表示同意连接），所以服务器会把syn包中的状态进行重置，
重置后syn包变为(SYN = 1, ACK = 1, seq = y)
```
SYN = 1：表示同意连接
ACK = 1：连接建立了，之后的ACK必须都置为1
seq = y：序列数随机，因为还没有数据，所以写什么都无所谓
```
然后，服务端会把刚才重置的syn包加上自己的ack包（sck = x + 1）
```
sck = x + 1：之前第一次握手的时候序列号说是发送的是seq=x第x位数据，所以我下次要的是x+1位的数据
```
发送给客户端，此时，服务端进行接收状态
【3】第三次握手：客户端接收到服务器的syn包和ack包后，向服务器发送ack确认包(ACK = 1, seq = x + 1, ack = y + 1)
```
ACK = 1：连接建立了
seq = x + 1：客户端告诉服务端我就发送的第一个字节就是你要的x+1
ack = y + 1：先前第二次握手，服务端告诉客户端说自己发的是第y位数据，所以我要y+1位的数据
```
此包发送完毕，客户端和服务器进入RSTABLISHEN状态，完成三次握手

2、http的四次挥手（关闭连接）？
前记：为什么要进行4次挥手？
```
由于TCP连接是全双工的，因此每个方向都必须单独进行关闭，这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接.
收到一个FIN只意味着这一方向没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
```
【1】第一次挥手：客户端发送一个FIN包(FIN = 1, seq = u)，用来关闭客户端A到服务器B的数据传送。
```
FIN = 1:tcp协议中的一个标志位,表示要释放连接了
seq = u:这个代表之前传递的数据的位置
```
【2】第二次挥手：服务器B收到这个FIN包(FIN = 1, seq = u)，它发回一个ACK(ACK = 1, seq = v, ack = u + 1)，
确认序号为收到的序号加1 ，一个FIN将占用一个序号。
```
ACK = 1：当前还是连接状态
ack = u + 1：客户端告诉服务端它发的是第u位数据，所以服务端告诉客户端服务端需要u+1位数据
seq = v：这里指的是之前已经发过的很多数据的序号
```
【3】第三次挥手：服务器B关闭与客户端A的连接，发送一个FIN包(FIN = 1, seq = w, ack = u + 1)给客户端A
```
FIN = 1:代表关闭连接
ack = u + 1：因为客户端直接不发数据了，所以第二段第三段的ack都是u+1
seq = w：代表之前发送的很多数据的序号
```
【4】第四次挥手：客户端收到服务端的FIN包后，客户端发回ACK(ACK = 1, seq = u + 1, ack = w + 1)报文确认，并将确认序号设置为收到序号加1
```
ACK = 1:当前还是连接状态
seq = u + 1:因为服务端已经不发消息了，所以序列号位置和之前服务端返回的相同
ack = w + 1:由于第三次握手服务端告诉我之前发送的序列号为w，所以我需要给它发的序号为w+1
```

注意：四次挥手中的第2次和第3次都是服务端发起的